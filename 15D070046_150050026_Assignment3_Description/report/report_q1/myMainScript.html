
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>myMainScript</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-01"><meta name="DC.source" content="myMainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Q1</a></li><li><a href="#3">1(a)</a></li><li><a href="#4">1(c) - Comparison</a></li><li><a href="#5">1(d) - deltaT and deltaTheta values</a></li><li><a href="#6">1(e) - deltaS values</a></li></ul></div><pre class="codeinput">clear;

tic;
</pre><h2 id="2">Q1</h2><pre class="codeinput">img = phantom(128);
</pre><h2 id="3">1(a)</h2><p>
<b>Justification for deltaS</b> : For step size <1, computations would be more,  whereas for >1, the smoothness of the transform image is
lost because it would lead to very coarse approximations. So, considering the tradeoff between two, optimal choice for step size would be 1.
<br>
<b>Interpolation scheme</b> : We used the default interpolation scheme in interp2, i.e.  bilinear interpolation. Other schemes like nearest
neighbour would have been faster but would be a very bad approximation for line integrals. Bilinear interpolation on the other hand is a good
measure to approximate line integrals.
</p><h2 id="4">1(c) - Comparison</h2><pre class="codeinput">deltaT = 5;
deltaTheta = 5;

figure(1);
subplot(1,3,1);
deltaS = 0.5;
RT_1 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_1)
title(<span class="string">'RT with \Deltas = 0.5'</span>);

subplot(1,3,2);
deltaS = 1;
RT_2 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_2)
title(<span class="string">'RT with \Deltas = 1'</span>);

subplot(1,3,3);
deltaS = 3;
RT_3 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_3)
title(<span class="string">'RT with \Deltas = 3'</span>);


t = -90:deltaT:90;
theta = 0:deltaTheta:180-deltaTheta;
index_0 = find(theta == 0);
index_90 = find(theta == 90);

figure(2);
subplot(2,3,1);
plot(t, RT_1(:, index_0));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf1(t, \Theta=0)'</span>)
title(<span class="string">'RT for \Theta=0 &amp; \Deltas=0.5'</span>)

subplot(2,3,2);
plot(t, RT_2(:, index_0));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf2(t, \Theta=0)'</span>)
title(<span class="string">'RT for \Theta=0 &amp; \Deltas=1'</span>)

subplot(2,3,3);
plot(t, RT_3(:, index_0));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf3(t, \Theta=0)'</span>)
title(<span class="string">'RT for \Theta=0 &amp; \Deltas=3'</span>)

subplot(2,3,4);
plot(t, RT_1(:, index_90));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf1(t, \Theta=90)'</span>)
title(<span class="string">'RT for \Theta=90 &amp; \Deltas=0.5'</span>)

subplot(2,3,5);
plot(t, RT_2(:, index_90));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf2(t, \Theta=90)'</span>)
title(<span class="string">'RT for \Theta=90 &amp; \Deltas=1'</span>)

subplot(2,3,6);
plot(t, RT_3(:, index_90));
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'Rf3(t, \Theta=90)'</span>)
title(<span class="string">'RT for \Theta=90 &amp; \Deltas=3'</span>)

<span class="comment">% &lt;html&gt;</span>
<span class="comment">% For deltaS=3.0, 1D plot appears to be the roughest as choosing larger step size would lead to a coarse and bad</span>
<span class="comment">% approximation of the line integral.</span>
<span class="comment">% &lt;br&gt;</span>
<span class="comment">% For deltaS values 0.5 and 1, both the radon transform image and 1D plot looks almost the same because of the</span>
<span class="comment">% bilinear inteprolation scheme. For deltaS values less than 1, the number of points for which interpolation needs</span>
<span class="comment">% to be done between two pixels increase, but as it as linear scheme, the sum remains the same.</span>
<span class="comment">% &lt;/html&gt;</span>
</pre><img vspace="5" hspace="5" src="myMainScript_01.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_02.png" alt=""> <h2 id="5">1(d) - deltaT and deltaTheta values</h2><pre class="codeinput">RT = myRadonTrans(img, 1.0, 1.0, 1.0);
figure(3);
imagesc(RT)
title(<span class="string">'RT with \Deltat = \Delta\Theta = \Deltas = 1'</span>);
<span class="comment">% &lt;html&gt;</span>
<span class="comment">% As evident from the above plot, if we set deltaT = deltaTheta = 1, we obtain a much smoother radon transform</span>
<span class="comment">% image than the one obtained for deltaT = deltaTheta = 5. So, ideally this should be selected. But, it takes</span>
<span class="comment">% much more time to compute. Also, practically smaller values of deltaT and deltaTheta would also mean more X-ray</span>
<span class="comment">% exposure to the patients which is not desirable&lt;br&gt;</span>
<span class="comment">% So there is a tradeoff between smooth reconstruction and computation time. Along with these, there are some</span>
<span class="comment">% practical factors which come into consideration.</span>
<span class="comment">% &lt;/html&gt;</span>
</pre><img vspace="5" hspace="5" src="myMainScript_03.png" alt=""> <h2 id="6">1(e) - deltaS values</h2><p>
The resolution of the image determines the number of pixels to be chosen on the grid. For regions containing more
complex features, more pixels would be required for accurate reconstruciton and thus more resolution.
By accounting the tradeoff, the ideal value of deltaS should be taken to be the size of each pixel in the
grid as more smaller values of deltaS do not give appreciable increase in reconstruction.
For values of deltaS << 1, the computation time increases because integral computations increase but there is
not much imporvement. The computation time is more because matrix A would be very large and hence, each iteration
would require more computations. <br>
On the other hand, for deltaS values >> 1, the computed integrals would be a very bad approximation to the
actual line integrals and thus will result in a poor reconstruction.
</p><pre class="codeinput">toc;
</pre><pre class="codeoutput">Elapsed time is 11.240641 seconds.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear;

tic;

%% Q1
img = phantom(128);

%% 1(a)
% <html>
% <b>Justification for deltaS</b> : For step size <1, computations would be more,  whereas for >1, the smoothness of the transform image is
% lost because it would lead to very coarse approximations. So, considering the tradeoff between two, optimal choice for step size would be 1.
% <br>
% <b>Interpolation scheme</b> : We used the default interpolation scheme in interp2, i.e.  bilinear interpolation. Other schemes like nearest 
% neighbour would have been faster but would be a very bad approximation for line integrals. Bilinear interpolation on the other hand is a good
% measure to approximate line integrals.
% </html>

%% 1(c) - Comparison
deltaT = 5;
deltaTheta = 5;

figure(1);
subplot(1,3,1);
deltaS = 0.5;
RT_1 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_1)
title('RT with \Deltas = 0.5');

subplot(1,3,2);
deltaS = 1;
RT_2 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_2)
title('RT with \Deltas = 1');

subplot(1,3,3);
deltaS = 3;
RT_3 = myRadonTrans(img, deltaT, deltaTheta, deltaS);
imagesc(RT_3)
title('RT with \Deltas = 3');


t = -90:deltaT:90;
theta = 0:deltaTheta:180-deltaTheta;
index_0 = find(theta == 0);
index_90 = find(theta == 90);

figure(2);
subplot(2,3,1);
plot(t, RT_1(:, index_0));
xlabel('t')
ylabel('Rf1(t, \Theta=0)') 
title('RT for \Theta=0 & \Deltas=0.5')

subplot(2,3,2);
plot(t, RT_2(:, index_0));
xlabel('t')
ylabel('Rf2(t, \Theta=0)') 
title('RT for \Theta=0 & \Deltas=1')

subplot(2,3,3);
plot(t, RT_3(:, index_0));
xlabel('t')
ylabel('Rf3(t, \Theta=0)') 
title('RT for \Theta=0 & \Deltas=3')

subplot(2,3,4);
plot(t, RT_1(:, index_90));
xlabel('t')
ylabel('Rf1(t, \Theta=90)') 
title('RT for \Theta=90 & \Deltas=0.5')

subplot(2,3,5);
plot(t, RT_2(:, index_90));
xlabel('t')
ylabel('Rf2(t, \Theta=90)') 
title('RT for \Theta=90 & \Deltas=1')

subplot(2,3,6);
plot(t, RT_3(:, index_90));
xlabel('t')
ylabel('Rf3(t, \Theta=90)') 
title('RT for \Theta=90 & \Deltas=3')

% <html> 
% For deltaS=3.0, 1D plot appears to be the roughest as choosing larger step size would lead to a coarse and bad 
% approximation of the line integral.
% <br>
% For deltaS values 0.5 and 1, both the radon transform image and 1D plot looks almost the same because of the 
% bilinear inteprolation scheme. For deltaS values less than 1, the number of points for which interpolation needs
% to be done between two pixels increase, but as it as linear scheme, the sum remains the same.
% </html>


%% 1(d) - deltaT and deltaTheta values
RT = myRadonTrans(img, 1.0, 1.0, 1.0);
figure(3);
imagesc(RT)
title('RT with \Deltat = \Delta\Theta = \Deltas = 1');
% <html>
% As evident from the above plot, if we set deltaT = deltaTheta = 1, we obtain a much smoother radon transform 
% image than the one obtained for deltaT = deltaTheta = 5. So, ideally this should be selected. But, it takes 
% much more time to compute. Also, practically smaller values of deltaT and deltaTheta would also mean more X-ray 
% exposure to the patients which is not desirable<br>
% So there is a tradeoff between smooth reconstruction and computation time. Along with these, there are some
% practical factors which come into consideration.
% </html>


%% 1(e) - deltaS values
% <html>
% The resolution of the image determines the number of pixels to be chosen on the grid. For regions containing more
% complex features, more pixels would be required for accurate reconstruciton and thus more resolution.
% By accounting the tradeoff, the ideal value of deltaS should be taken to be the size of each pixel in the
% grid as more smaller values of deltaS do not give appreciable increase in reconstruction.
% For values of deltaS << 1, the computation time increases because integral computations increase but there is
% not much imporvement. The computation time is more because matrix A would be very large and hence, each iteration
% would require more computations. <br>
% On the other hand, for deltaS values >> 1, the computed integrals would be a very bad approximation to the 
% actual line integrals and thus will result in a poor reconstruction.
% </html>
toc;
##### SOURCE END #####
--></body></html>